# クエリ比較

## 目的
2つのクエリを多角的に比較し、どちらが優れているか総合的に判断する

---

## 比較の観点

### 1. 実行計画の違い

#### チェック項目

| 項目 | 確認ポイント | 望ましい状態 |
|------|------------|------------|
| **アクセス方法（type）** | Table scan / Index lookup | Index lookup |
| **結合アルゴリズム** | Nested Loops / Hash / Sort Merge | 適切なアルゴリズム選択 |
| **テーブルアクセス回数** | 同じテーブルを何回読むか | 少ない方が良い |
| **推定コスト（cost）** | オプティマイザの推定コスト | 低い方が良い |

#### 確認方法

```sql
-- クエリA
EXPLAIN FORMAT=TREE
<クエリA>;

-- クエリB
EXPLAIN FORMAT=TREE
<クエリB>;
```

**比較ポイント:**
- どちらがシンプルな実行計画か
- どちらがテーブルアクセス回数が少ないか
- どちらが推定コストが低いか

**参照:** [tasks/read-execution-plan.md](./read-execution-plan.md)

---

### 2. 推定/実測の行数

#### チェック項目

| 項目 | 確認方法 | 望ましい状態 |
|------|---------|------------|
| **推定検査行数（rows）** | EXPLAIN の rows 列 | 少ない方が良い |
| **実測行数** | EXPLAIN ANALYZE の actual rows | 少ない方が良い |
| **推定と実測の差** | 推定 vs 実測の比較 | 差が小さい方が良い |

#### 確認方法

```sql
-- 推定値
EXPLAIN
<クエリ>;

-- 実測値（注意: 実際に実行される）
EXPLAIN ANALYZE
<クエリ>;
```

**判断基準:**
- **推定検査行数が少ない** → 効率的
- **推定と実測の差が小さい** → 統計情報が正確、実行計画が安定

---

### 3. インデックス使用状況

#### チェック項目

| 項目 | 確認ポイント | 望ましい状態 |
|------|------------|------------|
| **インデックス使用の有無** | key 列 | インデックス使用 |
| **インデックスのタイプ** | type 列（const/ref/range） | const > ref > range |
| **カバリングインデックス** | Extra: Using index | あり |

#### 確認方法

```sql
EXPLAIN
<クエリ>;
```

**出力例:**
```
| type  | key         | Extra        |
|-------|-------------|--------------|
| ref   | idx_user_id | Using index  |
```

**判断基準:**
- **key が NULL でない** → インデックス使用
- **type が const/ref/range** → 効率的
- **Extra に Using index** → カバリングインデックス（最速）

**参照:** [tasks/read-execution-plan.md](./read-execution-plan.md#type-アクセスタイプ)

---

### 4. ソート/一時テーブルの使用

#### チェック項目

| 項目 | 確認ポイント | 望ましい状態 |
|------|------------|------------|
| **ソート処理** | Extra: Using filesort | なし |
| **一時テーブル** | Extra: Using temporary | なし |
| **両方の組み合わせ** | Using filesort; Using temporary | なし（最悪） |

#### 確認方法

```sql
EXPLAIN
<クエリ>;
```

**判断基準:**
- **Using filesort / Using temporary がない** → 最良
- **Using filesort のみ** → 要注意（データ量によってはTEMP落ち）
- **Using temporary のみ** → 要注意（データ量によってはTEMP落ち）
- **両方あり** → 最悪（高確率でTEMP落ち）

**TEMP落ちとは:**
- メモリ内で処理しきれず、ディスクに書き出す現象
- パフォーマンスが劇的に悪化（10〜100倍遅くなる）

**参照:** [knowledge/temp-fall.md](../knowledge/temp-fall.md)

---

### 5. 可読性・保守性

#### チェック項目

| 項目 | 確認ポイント | 望ましい状態 |
|------|------------|------------|
| **クエリの長さ** | 行数、複雑性 | シンプル |
| **サブクエリのネスト** | ネストの深さ | 浅い（1〜2階層） |
| **UNION の使用** | 同じテーブルを複数回アクセス | なし（CASE式で代替） |
| **意図の明確さ** | 何をしたいか明確か | 明確 |

#### 判断基準

**可読性が高いクエリ:**
- ネストが浅い（1〜2階層）
- CASE式を使って1回のスキャン
- ウィンドウ関数で簡潔に記述
- 意図が明確（変数名、列名が適切）

**可読性が低いクエリ:**
- ネストが深い（3階層以上）
- サブクエリで同じテーブルに複数回アクセス
- 複雑なUNION
- 意図が不明瞭

**トレードオフ:**
- パフォーマンスと可読性はトレードオフになることがある
- 頻繁に実行されるクエリ → パフォーマンス優先
- 稀にしか実行されないクエリ → 可読性優先

---

## 比較手順

### Step 1: 両方のクエリのEXPLAINを取得

#### 手順

```sql
-- クエリA の実行計画
EXPLAIN FORMAT=TREE
<クエリA>;

-- クエリB の実行計画
EXPLAIN FORMAT=TREE
<クエリB>;
```

#### 記録すべき情報

| 項目 | クエリA | クエリB |
|------|---------|---------|
| type | | |
| key | | |
| rows | | |
| cost | | |
| Extra | | |

---

### Step 2: 各観点で比較

#### 比較表

| 観点 | クエリA | クエリB | 判定 |
|------|---------|---------|------|
| **1. 実行計画** | | | |
| - アクセス方法（type） | | | |
| - インデックス使用（key） | | | |
| - 推定コスト（cost） | | | |
| - テーブルアクセス回数 | | | |
| **2. 推定/実測行数** | | | |
| - 推定検査行数（rows） | | | |
| - 実測行数（actual rows） | | | |
| **3. インデックス** | | | |
| - インデックス使用 | | | |
| - カバリングインデックス | | | |
| **4. ソート/一時テーブル** | | | |
| - Using filesort | | | |
| - Using temporary | | | |
| **5. 可読性・保守性** | | | |
| - クエリの長さ | | | |
| - ネストの深さ | | | |
| - 意図の明確さ | | | |

---

### Step 3: 総合判定

#### 判定基準

**重み付け（推奨）:**

| 観点 | 重要度 | 理由 |
|------|--------|------|
| **実行計画** | ★★★★★ | パフォーマンスに直結 |
| **推定/実測行数** | ★★★★☆ | I/O削減の指標 |
| **インデックス使用** | ★★★★★ | 最重要（速度を左右） |
| **ソート/一時テーブル** | ★★★★☆ | TEMP落ちリスク |
| **可読性・保守性** | ★★★☆☆ | 長期運用で重要 |

**総合判定の流れ:**

```
1. パフォーマンスで明確な差があるか？
   ├─ Yes → パフォーマンスが良い方を選択
   └─ No → 次へ

2. 可読性で明確な差があるか？
   ├─ Yes → 可読性が良い方を選択
   └─ No → どちらでも良い（好みの問題）

3. 実行頻度は？
   ├─ 頻繁 → パフォーマンス優先
   └─ 稀 → 可読性優先
```

---

## 出力フォーマット

### テンプレート

```markdown
## クエリ比較結果

### 比較対象

**クエリA:**
\```sql
<クエリA>
\```

**クエリB:**
\```sql
<クエリB>
\```

---

### 実行計画比較

#### クエリA の実行計画
\```
<EXPLAIN結果>
\```

#### クエリB の実行計画
\```
<EXPLAIN結果>
\```

---

### 観点別比較

| 観点 | クエリA | クエリB | 優位 |
|------|---------|---------|------|
| **1. 実行計画** | | | |
| アクセス方法（type） | [値] | [値] | A/B |
| インデックス使用（key） | [値] | [値] | A/B |
| 推定コスト（cost） | [値] | [値] | A/B |
| テーブルアクセス回数 | [回] | [回] | A/B |
| **2. 推定/実測行数** | | | |
| 推定検査行数（rows） | [値] | [値] | A/B |
| 実測行数（actual rows） | [値] | [値] | A/B |
| **3. インデックス** | | | |
| インデックス使用 | あり/なし | あり/なし | A/B |
| カバリングインデックス | あり/なし | あり/なし | A/B |
| **4. ソート/一時テーブル** | | | |
| Using filesort | あり/なし | あり/なし | A/B |
| Using temporary | あり/なし | あり/なし | A/B |
| **5. 可読性・保守性** | | | |
| クエリの長さ | [行数] | [行数] | A/B |
| ネストの深さ | [階層] | [階層] | A/B |
| 意図の明確さ | 高/中/低 | 高/中/低 | A/B |

---

### 総合判定

**結論:** [クエリA / クエリB] を推奨

**理由:**
1. [理由1]
2. [理由2]
3. [理由3]

**推定パフォーマンス向上:**
- 推定コスト: [削減率]%削減
- 推定検査行数: [削減率]%削減
- 推定実行時間: [削減率]%高速化

**注意事項:**
- [注意点があれば記載]
```

---

## 実践例

### 例1: UNION vs CASE式

#### 比較対象

**クエリA（UNION）:**
```sql
SELECT item_name, year, price_tax_ex AS price
FROM Items
WHERE year <= 2001
UNION ALL
SELECT item_name, year, price_tax_in AS price
FROM Items
WHERE year >= 2002;
```

**クエリB（CASE式）:**
```sql
SELECT item_name, year,
       CASE WHEN year <= 2001 THEN price_tax_ex
            WHEN year >= 2002 THEN price_tax_in
       END AS price
FROM Items;
```

---

#### 実行計画比較

**クエリA（UNION）:**
```
-> Append
   -> Table scan on Items (cost=0.55 rows=5)   ← 1回目
   -> Table scan on Items (cost=0.55 rows=5)   ← 2回目
```

**クエリB（CASE式）:**
```
-> Table scan on Items (cost=0.55 rows=5)   ← 1回だけ！
```

---

#### 観点別比較

| 観点 | クエリA（UNION） | クエリB（CASE式） | 優位 |
|------|----------------|-----------------|------|
| **1. 実行計画** | | | |
| アクセス方法（type） | ALL | ALL | 同じ |
| インデックス使用（key） | NULL | NULL | 同じ |
| 推定コスト（cost） | 1.1 | 0.55 | **B** |
| テーブルアクセス回数 | 2回 | 1回 | **B** |
| **2. 推定/実測行数** | | | |
| 推定検査行数（rows） | 10行 | 5行 | **B** |
| **3. インデックス** | | | |
| インデックス使用 | なし | なし | 同じ |
| **4. ソート/一時テーブル** | | | |
| Using filesort | なし | なし | 同じ |
| Using temporary | なし | なし | 同じ |
| **5. 可読性・保守性** | | | |
| クエリの長さ | 7行 | 5行 | **B** |
| ネストの深さ | 0階層 | 0階層 | 同じ |
| 意図の明確さ | 中 | 高 | **B** |

---

#### 総合判定

**結論:** **クエリB（CASE式）** を推奨

**理由:**
1. テーブルアクセス回数が半減（2回 → 1回）
2. 推定コストが50%削減（1.1 → 0.55）
3. クエリがシンプルで読みやすい

**推定パフォーマンス向上:**
- 推定コスト: **50%削減**
- 推定検査行数: **50%削減**
- I/Oコスト: **50%削減**

**参照:** [examples/before-after.md](../examples/before-after.md#条件分岐union--case式)

---

### 例2: サブクエリ vs ウィンドウ関数

#### 比較対象

**クエリA（サブクエリ）:**
```sql
SELECT S1.shop_id, S1.shop_name, S1.rating,
       (SELECT MAX(rating)
        FROM Shops S2
        WHERE S2.shop_id = S1.shop_id) AS max_rating
FROM Shops S1;
```

**クエリB（ウィンドウ関数）:**
```sql
SELECT shop_id, shop_name, rating,
       MAX(rating) OVER (PARTITION BY shop_id) AS max_rating
FROM Shops;
```

---

#### 実行計画比較

**クエリA（サブクエリ）:**
```
-> Table scan on S1 (cost=6.25 rows=60)
   -> Subquery (correlated)
      -> Table scan on S2 (cost=6.25 rows=60)  ← 各行ごとに実行
```

**クエリB（ウィンドウ関数）:**
```
-> Window aggregate
   -> Sort: Shops.shop_id
      -> Table scan on Shops (cost=6.25 rows=60)  ← 1回だけ
```

---

#### 観点別比較

| 観点 | クエリA（サブクエリ） | クエリB（ウィンドウ関数） | 優位 |
|------|-------------------|---------------------|------|
| **1. 実行計画** | | | |
| アクセス方法（type） | ALL | ALL | 同じ |
| 推定コスト（cost） | 375 (6.25 × 60) | 6.25 | **B** |
| テーブルアクセス回数 | 60回 | 1回 | **B** |
| **2. 推定/実測行数** | | | |
| 推定検査行数（rows） | 3,600行 | 60行 | **B** |
| **3. インデックス** | | | |
| インデックス使用 | なし | なし | 同じ |
| **4. ソート/一時テーブル** | | | |
| Using filesort | なし | あり | A |
| Using temporary | なし | なし | 同じ |
| **5. 可読性・保守性** | | | |
| クエリの長さ | 5行 | 3行 | **B** |
| ネストの深さ | 2階層 | 0階層 | **B** |
| 意図の明確さ | 中 | 高 | **B** |

---

#### 総合判定

**結論:** **クエリB（ウィンドウ関数）** を推奨

**理由:**
1. テーブルアクセス回数が劇的に削減（60回 → 1回）
2. 推定コストが約98%削減（375 → 6.25）
3. クエリがシンプルで可読性が高い

**推定パフォーマンス向上:**
- 推定コスト: **98%削減**
- 推定検査行数: **98%削減**（3,600行 → 60行）
- 推定実行時間: **約60倍高速化**

**注意事項:**
- クエリBは `Using filesort` が発生するが、テーブルアクセスが1回なので圧倒的に速い
- データ量が増えても、クエリBの方が安定してパフォーマンスが良い

**参照:** [knowledge/subquery-problems.md](../knowledge/subquery-problems.md)

---

### 例3: N+1問題

#### 比較対象

**クエリA（ループでSQL発行）:**
```java
// ユーザー一覧取得
List<User> users = userRepository.findAll();  // 1回

// 各ユーザーの注文数を取得
for (User user : users) {
    int count = orderRepository.countByUserId(user.getId());  // N回
    user.setOrderCount(count);
}
```

**実行されるSQL:**
```sql
-- 1. ユーザー一覧
SELECT * FROM users;  -- 1回

-- 2. 各ユーザーの注文数（100回実行）
SELECT COUNT(*) FROM orders WHERE user_id = 1;
SELECT COUNT(*) FROM orders WHERE user_id = 2;
...
SELECT COUNT(*) FROM orders WHERE user_id = 100;
```

---

**クエリB（JOIN で一括取得）:**
```sql
SELECT u.id, u.name, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;
```

---

#### 観点別比較

| 観点 | クエリA（N+1問題） | クエリB（JOIN） | 優位 |
|------|-----------------|---------------|------|
| **1. 実行計画** | | | |
| SQL実行回数 | 101回（1 + 100） | 1回 | **B** |
| ネットワークラウンドトリップ | 101回 | 1回 | **B** |
| **2. 推定/実測行数** | | | |
| 推定検査行数（合計） | 約10,000行 | 100行 | **B** |
| **3. インデックス** | | | |
| インデックス使用 | あり（orders.user_id） | あり | 同じ |
| **4. ソート/一時テーブル** | | | |
| Using filesort | なし | なし | 同じ |
| Using temporary | なし | あり | A |
| **5. 可読性・保守性** | | | |
| コードの長さ | 5行（Java） | 1行（SQL） | **B** |
| 意図の明確さ | 低（ループが見えない） | 高（1つのSQLで完結） | **B** |

---

#### 総合判定

**結論:** **クエリB（JOIN）** を推奨

**理由:**
1. SQL実行回数が劇的に削減（101回 → 1回）
2. ネットワークラウンドトリップが削減
3. アプリケーションコードがシンプル

**推定パフォーマンス向上:**
- SQL実行回数: **99%削減**（101回 → 1回）
- ネットワークラウンドトリップ: **99%削減**
- 推定実行時間: **約10〜50倍高速化**

**注意事項:**
- クエリBは `Using temporary` が発生するが、それでもN+1問題よりは圧倒的に速い
- ユーザー数が増えても、クエリBは1回のSQLで済む

**参照:** [knowledge/anti-patterns.md](../knowledge/anti-patterns.md#ぐるぐる系n1問題)

---

## 総合判定の基準

### パフォーマンス重視の場合

**優先順位:**
1. **推定コスト** - 低い方が良い
2. **テーブルアクセス回数** - 少ない方が良い
3. **インデックス使用** - 使っている方が良い
4. **ソート/一時テーブル** - ない方が良い
5. **可読性** - 同程度なら考慮

**判定フロー:**
```
推定コストが50%以上削減？
  ├─ Yes → パフォーマンスが良い方を選択
  └─ No → 次へ

テーブルアクセス回数が半減以上？
  ├─ Yes → アクセス回数が少ない方を選択
  └─ No → 次へ

その他の観点で総合判断
```

---

### 可読性重視の場合

**優先順位:**
1. **意図の明確さ** - 明確な方が良い
2. **クエリの長さ** - 短い方が良い
3. **ネストの深さ** - 浅い方が良い
4. **パフォーマンス** - 同程度なら考慮

**判定フロー:**
```
実行頻度は？
  ├─ 頻繁（秒間100回以上） → パフォーマンス優先
  │
  └─ 稀（日次バッチ等） → 可読性優先
     ├─ 可読性が高い方を選択
     └─ ただし、パフォーマンスが10倍以上悪い場合は再考
```

---

### トレードオフがある場合

**例:**
- クエリA: パフォーマンス高、可読性低
- クエリB: パフォーマンス低、可読性高

**判断基準:**

| 実行頻度 | 推奨 | 理由 |
|---------|------|------|
| **秒間100回以上** | クエリA（パフォーマンス優先） | ボトルネックになる |
| **秒間10〜100回** | 場合による | パフォーマンス差による |
| **日次バッチ** | クエリB（可読性優先） | 保守性が重要 |

**パフォーマンス差の閾値:**
- **10倍以上の差** → パフォーマンス優先
- **2〜10倍の差** → 実行頻度で判断
- **2倍以下の差** → 可読性優先

---

## チェックリスト

### 比較実施前
- [ ] 両方のクエリが同じ結果を返すことを確認
- [ ] EXPLAIN でテスト環境の実行計画を取得
- [ ] 可能なら EXPLAIN ANALYZE で実測値を取得

### 比較中
- [ ] 5つの観点で比較（実行計画、行数、インデックス、ソート/一時テーブル、可読性）
- [ ] 各観点で優劣を判定
- [ ] 重み付けを考慮

### 比較後
- [ ] 総合判定の理由を明確に記載
- [ ] 推定パフォーマンス向上率を計算
- [ ] 注意事項があれば記載
- [ ] 本番環境でも確認（可能なら）

---

## 参考リンク

- [examples/before-after.md](../examples/before-after.md) - 改善前後の例
- [tasks/review-query.md](./review-query.md) - SQLクエリレビュー
- [tasks/read-execution-plan.md](./read-execution-plan.md) - 実行計画の読み方
- [tasks/diagnose-slow-query.md](./diagnose-slow-query.md) - 遅いクエリの診断
- [knowledge/anti-patterns.md](../knowledge/anti-patterns.md) - アンチパターン集
